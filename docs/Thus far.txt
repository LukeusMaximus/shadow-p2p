### 1 ###
30/10/12

It turns out that scapy requires a change to it's socketry in order to talk to local applications due to the loopback link lay being entirely virtual i.e. packets are held in memory and passed to application that way.
This results in scapy requiring a different L3 socket to pass IP packets to the right place. Namely:

    conf.L3socket = L3RawSocket
    
and then IP packets get routed correctly. Isn't that nice?

It also appears that python lacks the capability to derive source IP from UDP packets received, at least at that layer; lower level sockets may be able to read the UDP headers.

### 2 ###
04/11/12

and this one for in scripts

scapy.config.conf.L3socket = scapy.supersocket.L3RawSocket

### 3 ###
11/11/12

It is a better idea to find some neutral mediator rather than attempting shotgun packet transmission.
This approach is more efficient bandwidth wise and probably saves time sending packets too.
Perhaps using the Google Drive API we can use google as a mediator to transmit data.
A mediator is usable if it doesn't reveal any info on the users' identity.

### 4 ###
16/11/12

Decided neutral mediators makes things too easy and uninteresting.

Tor:
Provides anonymity by having clients connect to the wider internet through a relay chain of their peers.
There are different encryption keys for each hop so no node knows where the message came from.
The end point of the client's communication on the open internet will appear to have come from a different IP.
The client can change routes through Tor and usually does so every few minutes.
This prevents future activities being linked to past ones.

### 5 ###
18/11/12

I2P:
Uses inbound tunnels and outbound tunnels.
Connects the endpoints of tunnels together in order to connect to another node.
Introduces the concept of "cover traffic" which is basically other traffic passing through that node that will help mask the traffic of a given user.

Freenet:
Peers connect to other nodes that they trust.
Nodes they connect to are more able to attack them.
Users can create and publish "freesites" which are webpages only availbale through Freenet

OFF System:
Unique concept involving the use of XORed data blocks to anonymise data.
Blocks are provably random and reusable, they are used to represent multiple data sources.
Turns copyright claims into logical contradictions.
Interesting but nothing towards peer anonymity

GNUnet:
Mainly for file sharing.
Features link encryption, deniability, anonymous / non-anonymous modes, economic resource distribution.

VPNs:
Generally, a VPN offers to hide your identity behind their company's IPs.
Clients connect to the VPN and from there connect to the wider internet.
Customers are offered various desirable features like anonymity and network speed.
These are paid for services and are paid via the usual means (credit card / paypal) but some can be paid for through Bitcoin.
A number of services claim that tracing a connecton back to the user who made it is usually impossible / infeasible on their systems due to a lack of logs.
There are loads of VPNs (so one may assume that business is booming).

If I have gotten this right, proxy servers are the single-hop bread and butter of anonymity whilst VPNs and P2P networks build on this single-hop anonymity principle.
VPNs use a commercial agglomeration of servers to form a network through which traffic can be forwarded.
P2P networks create anonymity through the use of participating machines as hops.
Anonymity is all about trust in these systems.
    - With proxy servers and VPNs you trust the entity that sets up the service.
    - With P2P networks trust is mutual but have the added advantage that there is no central part that can be targetted by governments or other malicious entities.

### 6 ###
27/11/12

Routing:
It is clear that a distance vector routing protocol will have to be used.
Routing algorithms are generally suited towards finding the shortest or most direct route between nodes.
However, low latency is not the goal with Shadow P2P, anonymity is.

http://nrlweb.cs.ucla.edu/publication/download/589/83-A_distributed_routing_algorithm_for_unidirectional_networks.pdf
The paper describes a form of routing where links are unidirectional (instead of bi-directional).
Nodes receive a tree representing their upstream nodes that allows the node to find route to every node on the network.

N-dimensional routing:
Form an n-dimensional hypercube of nodes. Link it up into a hypertoroid with uni-directional links.
Route packets using headers containing the distance from the current node to the destination in each dimension.
Fault tolerance by introducing wormholes.
Constant adaption through shrinking and expanding; achieved by adding and removing hyperplanes of wormholes.
Maintain a number of virtual points, V, where V > N such that V < 2N.

http://pdf.aminer.org/000/360/047/fault_tolerant_wormhole_routing_in_tori.pdf
The paper describes routing in toroids where links can fail.
Involves routing around the fault analogous to water flowing through a river (non-faulty links) around an island (faulty links)
Inappropriate as it assumes two way links.

### 7 ###
29/11/12

SVN checkout:
"svn checkout svn://svn.code.sf.net/p/lansim/code/trunk lansim-code"

Compile using:
"javac -d bin -cp .:lib/liquidlnf.jar src/buffer/*.java src/framework/*.java src/module/Pc/*.java src/module/*.java src/module/Router/*.java src/module/Node/*.java src/module/Hub/*.java src/module/SnWwA/*.java src/fio/*.java src/ui/*.java src/ui/main/*.java src/util/*.java"

Run using:
"java -cp .:../lib/liquidlnf.jar ui.main.ApplicationManager"
in the bin folder

### 8 ###
06/12/12

Make lists of theoretical and practical componenets required for the network.
https://wikis.bris.ac.uk/display/~cssjh/Luke+Murray

### 9 ###
10/12/12

Direction Order Routing investigated. Basically, packets go down one dimension of the toroid until in the correct postion in that dimension and then proceed down the other dimensions in a similar fashion. Assumes bi-directional communication. Toroidal broadcasting looked at briefly. Diagonal zig zagging used to broadcast out from centre of the grid. Not really cohesive to n-dimensional uni-directional hypertoroids. It would appear that even if these algorithms were applicable, they have no real application toward anonymity.

### 10 ###
11/12/12

It occurs to me that it becomes much harder to work out which node is shouting (i.e. is the source of some message / packet) when the node separated by being in another jurisdiction / on another ISP. In addition, it is hard to work out which of the shout's addresses is the true address when the destinations are similarly separated. Internet monitoring within a jurisdiction / an ISP will only be able to garner which node is participating if monitoring occurs down at the node level. This is prohibitively costly and thus spoofing may only be detected at a managed node (at, say, city level) and then there are a large number of possibilities for the source.

SHARC is apparently a faster alternative to dikjstras.

### 11 ###
14/12/12

An n-dimensional toroidal network can dynamically resize itself by doubling the network size in every dimension, resulting in N nodes becoming N * 2^n nodes. This leaves the network largely untouched by resizes; perhaps nodes could detect that it has happened upon seeing an address outside the current network size. We require that new nodes swap out with nodes publishing shouts, the node doing the publishing will need to hold at least 2 virtual locations on the toroid. Downstream neighbors need not be informed of the swap out but the new node will require shouts for these nodes. The old node should tell its old upstream neighbors of their new downstream neighbor because we want to verify that the old neighbor is leaving this position. If another node were to tell the upstream neighbors to stop sending to their downstream neighbor, malicious nodes could break apart the network quite easily. We can use the same swap-out procedure for nodes leaving the network; the leaving node replaces itself in all of its virtual locations by other volunteer nodes.

For fountain code transmission, have it such that the source will send the data as long as it receives a repeating signal from the destination. Nodes that drop mid transmission can then be detected.

### 12 ###
02/01/13

If we split shouts by direction then there is one needle in the hay stack. If we binary search the haystack, the haystack disappears leaving the needle. If put the shouts together we now have multiple needles in the combined haystack. Any attempt at a binary search can be detected after the search has started and before the search ends. Detection could be by having downstream nodes coordinate and measure relative packets received, a cooperative node should send equal amounts of traffic to both (there is a probablistic factor due to packet drop).

It turns out GridHelper gets Ipv4AddressHelper to use a new network for each node in both dimensions. Hilarious.

### 13 ###
13/01/13

Redesign shouts to only be valid for a few uses thus preventing searches. Reroute around burnt bridges.

### 14 ###
18/01/13

Shouts need not be discarded after a number of uses if it can be shown that a hostile node is not searching the shout. By placing multiple valid IPs of the network in the shout it can be ascertained if the shout is being searched. If some valid IPs in the shout are not sent to whilst others are then it can be assumed that the node is trying to search the shout for valid IPs. We obviously need to ensure that the unreliablity introduced by UDP is accounted for, some valid IP may not receive the message and may wrongly reject the communication.

This can be implemented as follows. First, have shouts consist of a unique identifier (e.g. UUID) and a list of IPs (very few of which are valid). Groups of nodes first collaborate to create such a shout without revealing their identities to the others in the group. Once the shout is created it can be used to contact any member of the group as each has donated its real identity. Nodes inside and outside the group can then use the shout to communicate and can verify that the shout is not being searched as follows. When a node uses the shout, each member of the shout group should receive a message if the node doing the sending is not being hostile. Each member of the group should use the same shout to send some confirmation message saying that they too have received the shout. If the sending node is in the group then they will also send a confirmation message, it then cannot be told whether the sender of the shout is in the group of not (which helps anonymity slightly). Only if all the nodes in the shout group receive the message do we consider responding. Shouts are supposed to be sent repeatedly (with some delay between the repeats) so evetually a fully confirmed shout will get through. There is no need for any acknowledgement of the confirmation shouts.

Consider the hostile node. The node desires to learn the identity of one or more peers in the network so needs to find an IP address it knows to be hosting a peer. The network may be host to a number of functions and many of those will involve nodes in the network responding to some request made by other nodes. The hostile node, then, could send requests to different sets of IP addresses in the shout and group those requests that yielded a response (group A) and group those that didn't (group B). If IP addresses appear more in group A than group B then it that address is more likely to be the identity of a participating peer. These groups can be assembled by performing some form of search on the list of IPs, e.g a binary search or linear search. Binary search: use half the IPs in the list when shouting and see if it yields a response, if it does, halve the list of IP addresses again and repeat, otherwise use the other half and repeat; when a single IP is left and it yields a response when a message is sent to it then it is certain to be a peer in the network and its anonymity is compromised. Linear search: remove one IP address at a time from the list until the shout doesn't yield a response, it may be assumed that the last IP address removed is a participating peer.

Each non-hostile node will want to prevent hostile nodes from obtaining their identity. If one of the nodes in the shout group sees that they are the only node that has not received the message the  current shout then it may be the case that their IP address id the first to be removed in a linear search. If they do not confirm the message (this is the correct inaction) then the attacker will flag their IP address as a participating node and their anonymity is broken. If they do confirm the message (i.e. they lie about having received it) then the attacker won't flag their IP address and their anonymity remains intact. Therefore a non-hostile node's best course of action is to lie. In our shout group model, if a single node's IP address is excluded from the shout, the first the node will hear of the message is the confirmations from all the other nodes. Once it receives the last confirmation and some further time has passed it may assume that it has been excluded from the shout and might then decide to lie. We can prevent nodes from being able to lie by requiring that confirmations contain a cryptohash of the confirming node's unique ID concatenated to some nonce from the message being confirmed. Without the original message, the node is unable to produce a valid confirmation and therefore is unable to lie. However, this doesn't solve the problem of the node being identified, it only gives the responding node a clear picture of the situation.

### 15 ###
19/01/13

There are 4 possibilities: 
1. The destination node receives the message and all other nodes in the shout group confirm.
2. The destination node receives the message but not all other nodes in the shout group confirm.
3. The destination node does not receive the message but all other nodes in the shout group confirm.
4. The destination node does not receive the message and not all other nodes in the shout group confirm.
In case 1, we can safely respond. In case 2, if there is a single non-receiving node, not responding will risk identifying the node. In case 3, the destination node risks identifying itself if it doesn't respond and in fact cannot respond as it doesn't have the request. In case 4 we can safely not respond.

The hostile node can either gradually increase or decrease the set of IP addresses in the shout it uses; the set used comes from the original shout it is provided. When the first method is used the nodes in the shout group will see the number of nodes receiving the messages increase. When the second method is used the nodes see the number of receivers decrease. If the nodes act such that the destination node will respond if all other nodes confirm then when the first method is used, the IP addresses included in the shout will increase until they hit all nodes. When the nodes respond, they risk identifying the last node added to the shout (as there is no way to know if the hostile node has added more IP addresses to their shout since adding this one). Similarly, if the nodes act such that they will respond if one or more nodes receive the shout then this risks identifying the first node. Similar cases occur when the hostile node decreases.

So we see that if hostile nodes can readily manipulate their shouts, they have a good chance of identifying nodes in the network. Can shouts be locked down in such a way that a hostile node cannot search through the list of IP addresses in the shout. Note that the search mechanism relies upon trying different sets of IP addresses when shouting and comparing the sets where responses were obtained to sets where responses were not obtained.

Dynamic send / don't send sets
    as the shout is used, addresses move between sets
    receivers know in advance what sets the sender should be using
    attacker can still change set membership of addresses and determine peerhood when it changes set membership of a valid IP
    
    
Once joined, receive constant traffic
    all items might be received with small probability
        requesting things merely increases probability of receiving it
        no way to tell if modification to shout IP address list caused response or not
    
### 16 ###
25/01/13

Following meeting with Simon:
    Theoretical approach entirely valid.
    Design components and prove they work individually.
        Show that if they work as parts, they work as a whole.
        Make really simple small emulations.
    Create diagram of areas where time needs to be spent.
    Idea is to convince reader of the design's functionality.
    Show that there isn't any similar research out there.
    Write about interesting ideas I have.
        Proof of work (POW) tokens to make joining difficult thus making attacks difficult.
            Ban hostile nodes by blacklisting their tokens.
            Must do another proof of work to rejoin.
    
    Parts:
        The shout.
        The network design.
            Utilise existing designs.
            Modify for shout based nature of network.
        How applications can be mounted on top of the network.
            New applications or modified existing ones?
            
### 17 ###
27/01/13

With shout groups, increasing send set attacks easily detectable and safe to ban hostile peer (as no message will be sent unless all nodes in shout group receive the message). Decreasing send set attacks can also be detected but it is harder to ban hostile node safely. Banning the hostile node immediately after one node stops receiving the shouts reveals that node as a participant. Banning the hostile node after a random number of shouts after detection doesn't help alleviate this situation as the hositle node can wait as long as they like before decreasing the send set further. Such a patient hostile node can simply wait until they are certain they haven't been caught before decreasing the send set by one again. The advantage we have over the hostile node is that, if we don't alter our behaviour once we detect their hostility, the hostile node doesn't know when, or if, it has been detected. We know that we must ban the hostile node before its shouts do not reach any node within the shout group; once this happens, the recipient in the shout group is unable to respond and therefore is forced into modifying its behaviour (i.e. it won't respond to a request it hasn't received because it cannot respond to the request). Whilst there is a possibility of banning hostile nodes when the shout group members believe the search will identify a random non-participating IP as the recipient, this solution is undesirable because there is no way to know for sure if the ban would identify a peer.

Instead we can have shout groups that exist only temporarily. Once a certain number of shouts have been sent, the shout group ceases responding to requests to the shout group. The sender must use a different shout to reach the network. If we have the shout group mutually pre-determine a number of times the shout can be used and then proceed to offer a new shout (for a different shout group) after the shout expires then if the shouting node is hostile, it will have its search interrupted before it can be completed. We will ensure that the hostile node will not complete its search with high probability by showing the probability that the first x IP addresses in a randomly ordered list of n containing all s of the shout group's IP addresses is very low. The shout need only reach a single node for us to be able to send the request on and generate a response so we only need the shout to expire before all the valid IPs are placed in the no-send set. This covers the case where one IP address is removed at a time. What about when more are removed at once? When a large number of IP addresses are removed from the send set (which corresponds to several of the valid IP addresses being removed from the send-set) like we might see in a binary search, we can safely ban the sender as they still have a large list of IP addresses to search. However, if the shout has c uses then if the sender removes n/c IP addresses everytime the hostile node can complete the search and will have a block of n/c addresses containing one or more valid IP addresses which narrows its search considerably (unless 1/(n/c) <= 1/(n/v) --> c <= v where v is the number of valid IP addresses).

exponentially increasing search certainty periods
    responder waits for number of shouts before responding
        increasing numbers of responses to same bad shout
        normal behaviour causes similar behaviour
        uses up shout lifetime
    responder waits a time delay before responding
        increasing as shout group members fail to receive the shout
        normal behaviour generates delay as well
proof of work per request
    only really delays the inevitable
sender must send request with sequence number
    receivers also keep track
    somehow use out-of-stepness to ban safely
    can detect when the sender has been sending to only invalid IPs between sending to valid IPs


Banning
    Make sure people not banned by hostile nodes
    Banning prevents someome being responded to by the shout group that banned them
        Doesn't affect other shout groups

### 18 ###
28/01/13

Randomly ban hostile peer in the the middle of their search; this will leave them with two lists of size n/2 with each containing roughly v/2 valid IP addresses. This gives the same valid address density as with the complete list. Therefore it is no different than if the attacker had cut the list in to 2 parts without interacting with the network at all and thus the attacker gains no information. 

Consider if there were multiple collaborating hostile nodes. Each has its own POW token. Suppose they split their search between them in some fashion, i.e. the shouts required to perform the search are distributed between the hostile nodes. We have the policy that a node is immediately banned if it stops sending to more than one valid IP at once. Therefore a node that has a clean history cannot pick up the search in the middle when the search has stopped sending to multiple valid IP addresses. In the case that a single valid address has been eliminated, we proceed as if that node had just been detected as starting a hostile search. In the case the search jumps before any valid IP is placed in the no-send set, we treat them as if no search has begun. Before the search switch, the first hostile node does not know if there are any valid IP addresses in its no-send set or not so when the switch occurs, the hostile party knows that either there is one valid IP in their no-send set or there are none. 

We can change the threshhold to be such that the ban occurs, at random, after nearly half of the valid IPs have changed sets. Combining this with multiple hostile nodes, we wouldn't ban the new node after the switch unless it had roughly half of the valid IPs in the no-send set. This is set up such that, if the first node suffers a ban caused by the random number of shouts after the hostile node stops sending to nearly half of the valid IP addresses, then continuing the search with the same send / no-send sets on the second node will be met with that second node being instantly banned. 

Consider hostile nodes within the shout group. The hostile party will now have information regarding how many nodes receive the shout. The node within the shout can use a different anonymous ID to perform the attack to prevent revealing that they are within the shout group. This information would make it incredibly easy to see when the search changes the set membership of one of the valid IP addresses. To counteract this, we note that a shout group contains the valid IP address of the destination node and that the purpose of the shout group is so that the destination node knows the sender is shouting loudly enough. I.e. the only node that is doing any responding is the destination node, other nodes within the shout group will need other shouts in order to receive messages. Taking this into account, we use the following procedure. The sender shouts the same request multiple times which should ensure reception at any valid IP it is shouting to. Once the number of received requests passes a threshhold for any node in the shout group, that node shouts to the shout group a message encrypted under the destination node's public key. When another node in the group received this token, that node shouts a message under the destination node's public key saying whether or not it has received a request from the anonymous ID given in the token. All nodes in the shout group will then have shouted to every other node a message saying that a message has come from the sender and an encrypted value stating if the node has received the shout or not.

This is flawed as the hostile node within the group can simply send a request to one IP address at a time; when the request hits a valid node, the hostile node will hear about it and can record the IP address of the node it sent the message to. We can instead send encrypted shouts under the public key of the destination node regarding every message received within a fixed time period. If these are sent continually, with the same size and with some IND-CPA encryption scheme then the non-destination receivers are unable to discern whether their request is being received or not beyond what they learn from receiving responses to their requests. This model does place the destination node in a powerful position within the shout group.

What if the destination node is hostile? This requires a method of ensuring that the destination node will only be given a message that the shout has been received by other nodes if all the nodes have received it. 

### 19 ###
29/01/13

We want to create a system whereby a number of parties reveal some information only if a certain number of other parties do the same. The only method of checking whether the other parties submit the information is through a public channel all the involved parties have access to. Can this be done through secret sharing?

If we have secrets shared such that the receipt is only confirmed if some threshold of parties confirm it then we should be able to recreate all our previously mentioned behaviours (e.g. link up the threshhold of this to the threshhold used for bans).

Within the shout group:
    Some number of nodes have received the message
        We assume hostile nodes have the message also
    Each node generates an encrypted message regardless of whether they received the message and shouts it
    Encrypted messages indicate whether or not a node has received the message
    Only if a number of nodes above a threshold have received the message can the messages be decrypted
    Nodes that have received the message cannot simply generate more secrets using the information they have or lie in order to decrypt the other people's messages.
    
### 20 ###
30/01/13

Commitment scheme

Sender sends encrypted secret shares under secret sharing scheme. Each party decrypts its share and shouts it. Only once t shares are shouted does the message become acknowledged. Would be great if it weren't for the fact this doesn't cover the hostile sender (which can recognise shares that it dealt).

Go around in a circle. Order the members somehow and pass around a message with some homomorphicly additive component. The message starts off with a hash of the message or other unique ID and the homomorphicly encrypted number set to 1 (because the starting node will have received the message). The message is then encrypted under the public key of the next person in the chain. They add 1 to the homorphic number if they have received the message and then proceed to pass the message on under the next person in chain's key. When the message reaches the party that started the message passing, they decrypt the homomorphic number and shout that the message has been received with that number of receipts.

Use symmetric encryption on a randomised acknowledgement of receipt. The key is derived from the message deterministically. Encrypt a number of times >= v. Keep record of all intermediate results. Send this round in the circle. Each party who has received the message can derive the key. They should then apply the key to the message if they have received it. When the message comes back to the first node, they can compare the message to their list of intermediate encryption results and determine the number of receipts for the given message. They can then shout the information and proof of results for verification. If the process is repeated by all nodes then the results can be verified (the received message should be receipted the same number of times by each party so each party should broadcast the same number of receipts). If the receipting process fails to return receipts above the threshold then it can be discarded without further thought.

Problem is that a hostile node in the shout group can decrypt the message multiple times to simulate more receipts. Instead we can adopt a multipart receipt approach where each party applies an encryption/decryption to just their part of a random bitstring, if they have received the message. Tampering like before is now no longer possible as tampering is easily detected by the first party. The first party knows what the parts of the bitstring should be in each of the nodes' cases. If the part of the bitstring is in neither it's original state or it's operation-applied state then it has been tampered with. In the event of tampering, the first party can simply leave the group. The operation applied can be a signature with the node's private key. When the first node in the chain receives the message back, they can check the parts of the message that are in their original state. For every other part, a verification with the respective public key is tried; if the verification matches the original message then that is counted as a reciept. Any other value that that part takes indicates tampering. However, this allows the first party to know the exact number of parties that receipted the message and can reveal identities if just one node receipts the message.

How do we know which message we are receipting? If the bitstring somehow indicates the message it is receipting for, or if it can be verified that it is a receipt for a certain message, then a hostile node knows that at least one node has received the message which can reveal a node's IP address. Instead, signature onto the bitstring also takes into account the message that is being signed; i.e. the signer adds the information on what message it is receipting.

### 21 ###
31/01/13

System needs to be such that it will only reveal the number of receipts if a threshold has been passed. Each node can only receipt once (i.e. cannot forge more receipts) so cannot pass threshold artificially. Perhaps some system whereby a receipt lowers the computational requirement of decrypting the number of receipts; once the number of receipts passes a threshold, the decryption becomes computationally feasible.

### 22 ###
01/02/13

Secret sharing where shares cannot be determined to be parts of the secret, even with knowledge of the secret.

http://cs5824.userapi.com/u11728334/docs/e516fb1fedc1/Moti_Yung_Advances_in_Cryptology_CRYPTO_2002_22.pdf#page=496
           
