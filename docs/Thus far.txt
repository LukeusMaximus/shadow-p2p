### 1 ###
30/10/12

It turns out that scapy requires a change to it's socketry in order to talk to local applications due to the loopback link lay being entirely virtual i.e. packets are held in memory and passed to application that way.
This results in scapy requiring a different L3 socket to pass IP packets to the right place. Namely:

    conf.L3socket = L3RawSocket
    
and then IP packets get routed correctly. Isn't that nice?

It also appears that python lacks the capability to derive source IP from UDP packets received, at least at that layer; lower level sockets may be able to read the UDP headers.

### 2 ###
04/11/12

and this one for in scripts

scapy.config.conf.L3socket = scapy.supersocket.L3RawSocket

### 3 ###
11/11/12

It is a better idea to find some neutral mediator rather than attempting shotgun packet transmission.
This approach is more efficient bandwidth wise and probably saves time sending packets too.
Perhaps using the Google Drive API we can use google as a mediator to transmit data.
A mediator is usable if it doesn't reveal any info on the users' identity.

### 4 ###
16/11/12

Decided neutral mediators makes things too easy and uninteresting.

Tor:
Provides anonymity by having clients connect to the wider internet through a relay chain of their peers.
There are different encryption keys for each hop so no node knows where the message came from.
The end point of the client's communication on the open internet will appear to have come from a different IP.
The client can change routes through Tor and usually does so every few minutes.
This prevents future activities being linked to past ones.

### 5 ###
18/11/12

I2P:
Uses inbound tunnels and outbound tunnels.
Connects the endpoints of tunnels together in order to connect to another node.
Introduces the concept of "cover traffic" which is basically other traffic passing through that node that will help mask the traffic of a given user.

Freenet:
Peers connect to other nodes that they trust.
Nodes they connect to are more able to attack them.
Users can create and publish "freesites" which are webpages only availbale through Freenet

OFF System:
Unique concept involving the use of XORed data blocks to anonymise data.
Blocks are provably random and reusable, they are used to represent multiple data sources.
Turns copyright claims into logical contradictions.
Interesting but nothing towards peer anonymity

GNUnet:
Mainly for file sharing.
Features link encryption, deniability, anonymous / non-anonymous modes, economic resource distribution.

VPNs:
Generally, a VPN offers to hide your identity behind their company's IPs.
Clients connect to the VPN and from there connect to the wider internet.
Customers are offered various desirable features like anonymity and network speed.
These are paid for services and are paid via the usual means (credit card / paypal) but some can be paid for through Bitcoin.
A number of services claim that tracing a connecton back to the user who made it is usually impossible / infeasible on their systems due to a lack of logs.
There are loads of VPNs (so one may assume that business is booming).

If I have gotten this right, proxy servers are the single-hop bread and butter of anonymity whilst VPNs and P2P networks build on this single-hop anonymity principle.
VPNs use a commercial agglomeration of servers to form a network through which traffic can be forwarded.
P2P networks create anonymity through the use of participating machines as hops.
Anonymity is all about trust in these systems.
    - With proxy servers and VPNs you trust the entity that sets up the service.
    - With P2P networks trust is mutual but have the added advantage that there is no central part that can be targetted by governments or other malicious entities.

### 6 ###
27/11/12

Routing:
It is clear that a distance vector routing protocol will have to be used.
Routing algorithms are generally suited towards finding the shortest or most direct route between nodes.
However, low latency is not the goal with Shadow P2P, anonymity is.

http://nrlweb.cs.ucla.edu/publication/download/589/83-A_distributed_routing_algorithm_for_unidirectional_networks.pdf
The paper describes a form of routing where links are unidirectional (instead of bi-directional).
Nodes receive a tree representing their upstream nodes that allows the node to find route to every node on the network.

N-dimensional routing:
Form an n-dimensional hypercube of nodes. Link it up into a hypertoroid with uni-directional links.
Route packets using headers containing the distance from the current node to the destination in each dimension.
Fault tolerance by introducing wormholes.
Constant adaption through shrinking and expanding; achieved by adding and removing hyperplanes of wormholes.
Maintain a number of virtual points, V, where V > N such that V < 2N.

http://pdf.aminer.org/000/360/047/fault_tolerant_wormhole_routing_in_tori.pdf
The paper describes routing in toroids where links can fail.
Involves routing around the fault analogous to water flowing through a river (non-faulty links) around an island (faulty links)
Inappropriate as it assumes two way links.

### 7 ###
29/11/12

SVN checkout:
"svn checkout svn://svn.code.sf.net/p/lansim/code/trunk lansim-code"

Compile using:
"javac -d bin -cp .:lib/liquidlnf.jar src/buffer/*.java src/framework/*.java src/module/Pc/*.java src/module/*.java src/module/Router/*.java src/module/Node/*.java src/module/Hub/*.java src/module/SnWwA/*.java src/fio/*.java src/ui/*.java src/ui/main/*.java src/util/*.java"

Run using:
"java -cp .:../lib/liquidlnf.jar ui.main.ApplicationManager"
in the bin folder

### 8 ###
06/12/12

Make lists of theoretical and practical componenets required for the network.
https://wikis.bris.ac.uk/display/~cssjh/Luke+Murray

### 9 ###
10/12/12

Direction Order Routing investigated. Basically, packets go down one dimension of the toroid until in the correct postion in that dimension and then proceed down the other dimensions in a similar fashion. Assumes bi-directional communication. Toroidal broadcasting looked at briefly. Diagonal zig zagging used to broadcast out from centre of the grid. Not really cohesive to n-dimensional uni-directional hypertoroids. It would appear that even if these algorithms were applicable, they have no real application toward anonymity.

### 10 ###
11/12/12

It occurs to me that it becomes much harder to work out which node is shouting (i.e. is the source of some message / packet) when the node separated by being in another jurisdiction / on another ISP. In addition, it is hard to work out which of the shout's addresses is the true address when the destinations are similarly separated. Internet monitoring within a jurisdiction / an ISP will only be able to garner which node is participating if monitoring occurs down at the node level. This is prohibitively costly and thus spoofing may only be detected at a managed node (at, say, city level) and then there are a large number of possibilities for the source.

SHARC is apparently a faster alternative to dikjstras.

### 11 ###
14/12/12

An n-dimensional toroidal network can dynamically resize itself by doubling the network size in every dimension, resulting in N nodes becoming N * 2^n nodes. This leaves the network largely untouched by resizes; perhaps nodes could detect that it has happened upon seeing an address outside the current network size. We require that new nodes swap out with nodes publishing shouts, the node doing the publishing will need to hold at least 2 virtual locations on the toroid. Downstream neighbors need not be informed of the swap out but the new node will require shouts for these nodes. The old node should tell its old upstream neighbors of their new downstream neighbor because we want to verify that the old neighbor is leaving this position. If another node were to tell the upstream neighbors to stop sending to their downstream neighbor, malicious nodes could break apart the network quite easily. We can use the same swap-out procedure for nodes leaving the network; the leaving node replaces itself in all of its virtual locations by other volunteer nodes.

For fountain code transmission, have it such that the source will send the data as long as it receives a repeating signal from the destination. Nodes that drop mid transmission can then be detected.

### 12 ###
02/01/13

If we split shouts by direction then there is one needle in the hay stack. If we binary search the haystack, the haystack disappears leaving the needle. If put the shouts together we now have multiple needles in the combined haystack. Any attempt at a binary search can be detected after the search has started and before the search ends. Detection could be by having downstream nodes coordinate and measure relative packets received, a cooperative node should send equal amounts of traffic to both (there is a probablistic factor due to packet drop).

It turns out GridHelper gets Ipv4AddressHelper to use a new network for each node in both dimensions. Hilarious.

### 13 ###
13/01/13

Redesign shouts to only be valid for a few uses thus preventing searches. Reroute around burnt bridges.

### 14 ###
18/01/13

Shouts need not be discarded after a number of uses if it can be shown that a hostile node is not searching the shout. By placing multiple valid IPs of the network in the shout it can be ascertained if the shout is being searched. If some valid IPs in the shout are not sent to whilst others are then it can be assumed that the node is trying to search the shout for valid IPs. We obviously need to ensure that the unreliablity introduced by UDP is accounted for, some valid IP may not receive the message and may wrongly reject the communication.

This can be implemented as follows. First, have shouts consist of a unique identifier (e.g. UUID) and a list of IPs (very few of which are valid). Groups of nodes first collaborate to create such a shout without revealing their identities to the others in the group. Once the shout is created it can be used to contact any member of the group as each has donated its real identity. Nodes inside and outside the group can then use the shout to communicate and can verify that the shout is not being searched as follows. When a node uses the shout, each member of the shout group should receive a message if the node doing the sending is not being hostile. Each member of the group should use the same shout to send some confirmation message saying that they too have received the shout. If the sending node is in the group then they will also send a confirmation message, it then cannot be told whether the sender of the shout is in the group of not (which helps anonymity slightly). Only if all the nodes in the shout group receive the message do we consider responding. Shouts are supposed to be sent repeatedly (with some delay between the repeats) so evetually a fully confirmed shout will get through. There is no need for any acknowledgement of the confirmation shouts.

Consider the hostile node. The node desires to learn the identity of one or more peers in the network so needs to find an IP address it knows to be hosting a peer. The network may be host to a number of functions and many of those will involve nodes in the network responding to some request made by other nodes. The hostile node, then, could send requests to different sets of IP addresses in the shout and group those requests that yielded a response (group A) and group those that didn't (group B). If IP addresses appear more in group A than group B then it that address is more likely to be the identity of a participating peer. These groups can be assembled by performing some form of search on the list of IPs, e.g a binary search or linear search. Binary search: use half the IPs in the list when shouting and see if it yields a response, if it does, halve the list of IP addresses again and repeat, otherwise use the other half and repeat; when a single IP is left and it yields a response when a message is sent to it then it is certain to be a peer in the network and its anonymity is compromised. Linear search: remove one IP address at a time from the list until the shout doesn't yield a response, it may be assumed that the last IP address removed is a participating peer.

Each non-hostile node will want to prevent hostile nodes from obtaining their identity. If one of the nodes in the shout group sees that they are the only node that has not received the message the  current shout then it may be the case that their IP address id the first to be removed in a linear search. If they do not confirm the message (this is the correct inaction) then the attacker will flag their IP address as a participating node and their anonymity is broken. If they do confirm the message (i.e. they lie about having received it) then the attacker won't flag their IP address and their anonymity remains intact. Therefore a non-hostile node's best course of action is to lie. In our shout group model, if a single node's IP address is excluded from the shout, the first the node will hear of the message is the confirmations from all the other nodes. Once it receives the last confirmation and some further time has passed it may assume that it has been excluded from the shout and might then decide to lie. We can prevent nodes from being able to lie by requiring that confirmations contain a cryptohash of the confirming node's unique ID concatenated to some nonce from the message being confirmed. Without the original message, the node is unable to produce a valid confirmation and therefore is unable to lie. However, this doesn't solve the problem of the node being identified, it only gives the responding node a clear picture of the situation.

### 15 ###
19/01/13

There are 4 possibilities: 
1. The destination node receives the message and all other nodes in the shout group confirm.
2. The destination node receives the message but not all other nodes in the shout group confirm.
3. The destination node does not receive the message but all other nodes in the shout group confirm.
4. The destination node does not receive the message and not all other nodes in the shout group confirm.
In case 1, we can safely respond. In case 2, if there is a single non-receiving node, not responding will risk identifying the node. In case 3, the destination node risks identifying itself if it doesn't respond and in fact cannot respond as it doesn't have the request. In case 4 we can safely not respond.

The hostile node can either gradually increase or decrease the set of IP addresses in the shout it uses; the set used comes from the original shout it is provided. When the first method is used the nodes in the shout group will see the number of nodes receiving the messages increase. When the second method is used the nodes see the number of receivers decrease. If the nodes act such that the destination node will respond if all other nodes confirm then when the first method is used, the IP addresses included in the shout will increase until they hit all nodes. When the nodes respond, they risk identifying the last node added to the shout (as there is no way to know if the hostile node has added more IP addresses to their shout since adding this one). Similarly, if the nodes act such that they will respond if one or more nodes receive the shout then this risks identifying the first node. Similar cases occur when the hostile node decreases.

So we see that if hostile nodes can readily manipulate their shouts, they have a good chance of identifying nodes in the network. Can shouts be locked down in such a way that a hostile node cannot search through the list of IP addresses in the shout. Note that the search mechanism relies upon trying different sets of IP addresses when shouting and comparing the sets where responses were obtained to sets where responses were not obtained.

Dynamic send / don't send sets
    as the shout is used, addresses move between sets
    receivers know in advance what sets the sender should be using
    attacker can still change set membership of addresses and determine peerhood when it changes set membership of a valid IP
    
    
Once joined, receive constant traffic
    all items might be received with small probability
        requesting things merely increases probability of receiving it
        no way to tell if modification to shout IP address list caused response or not
    
### 16 ###
25/01/13

Following meeting with Simon:
    Theoretical approach entirely valid.
    Design components and prove they work individually.
        Show that if they work as parts, they work as a whole.
        Make really simple small emulations.
    Create diagram of areas where time needs to be spent.
    Idea is to convince reader of the design's functionality.
    Show that there isn't any similar research out there.
    Write about interesting ideas I have.
        Proof of work tokens to make joining difficult thus making attacks difficult.
            Ban naughty nodes by blacklisting their tokens.
            Must do another proof of work to rejoin.
    
    Parts:
        The shout.
        The network design.
            Utilise existing designs.
            Modify for shout based nature of network.
        How applications can be mounted on top of the network.
            New applications or modified existing ones?
            




